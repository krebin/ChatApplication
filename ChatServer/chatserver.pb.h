// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatserver.proto

#ifndef PROTOBUF_chatserver_2eproto__INCLUDED
#define PROTOBUF_chatserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace chatserver {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_chatserver_2eproto();
void protobuf_AssignDesc_chatserver_2eproto();
void protobuf_ShutdownFile_chatserver_2eproto();

class ChatMessage;
class ListReply;
class ListRequest;
class LogInReply;
class LogInRequest;
class LogOutReply;
class LogOutRequest;
class ReceiveMessageReply;
class ReceiveMessageRequest;
class SendMessageReply;
class SendMessageRequest;

enum LogInReply_State {
  LogInReply_State_INVALID = 0,
  LogInReply_State_ALREADY = 1,
  LogInReply_State_SUCCESS = 2,
  LogInReply_State_LogInReply_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogInReply_State_LogInReply_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogInReply_State_IsValid(int value);
const LogInReply_State LogInReply_State_State_MIN = LogInReply_State_INVALID;
const LogInReply_State LogInReply_State_State_MAX = LogInReply_State_SUCCESS;
const int LogInReply_State_State_ARRAYSIZE = LogInReply_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogInReply_State_descriptor();
inline const ::std::string& LogInReply_State_Name(LogInReply_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogInReply_State_descriptor(), value);
}
inline bool LogInReply_State_Parse(
    const ::std::string& name, LogInReply_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogInReply_State>(
    LogInReply_State_descriptor(), name, value);
}
enum SendMessageRequest_State {
  SendMessageRequest_State_INITIAL = 0,
  SendMessageRequest_State_PROCESSING = 1,
  SendMessageRequest_State_SendMessageRequest_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SendMessageRequest_State_SendMessageRequest_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SendMessageRequest_State_IsValid(int value);
const SendMessageRequest_State SendMessageRequest_State_State_MIN = SendMessageRequest_State_INITIAL;
const SendMessageRequest_State SendMessageRequest_State_State_MAX = SendMessageRequest_State_PROCESSING;
const int SendMessageRequest_State_State_ARRAYSIZE = SendMessageRequest_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* SendMessageRequest_State_descriptor();
inline const ::std::string& SendMessageRequest_State_Name(SendMessageRequest_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    SendMessageRequest_State_descriptor(), value);
}
inline bool SendMessageRequest_State_Parse(
    const ::std::string& name, SendMessageRequest_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SendMessageRequest_State>(
    SendMessageRequest_State_descriptor(), name, value);
}
enum SendMessageReply_State {
  SendMessageReply_State_EXIST = 0,
  SendMessageReply_State_NO_EXIST = 1,
  SendMessageReply_State_SendMessageReply_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SendMessageReply_State_SendMessageReply_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SendMessageReply_State_IsValid(int value);
const SendMessageReply_State SendMessageReply_State_State_MIN = SendMessageReply_State_EXIST;
const SendMessageReply_State SendMessageReply_State_State_MAX = SendMessageReply_State_NO_EXIST;
const int SendMessageReply_State_State_ARRAYSIZE = SendMessageReply_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* SendMessageReply_State_descriptor();
inline const ::std::string& SendMessageReply_State_Name(SendMessageReply_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    SendMessageReply_State_descriptor(), value);
}
inline bool SendMessageReply_State_Parse(
    const ::std::string& name, SendMessageReply_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SendMessageReply_State>(
    SendMessageReply_State_descriptor(), name, value);
}
enum ReceiveMessageReply_State {
  ReceiveMessageReply_State_EMPTY = 0,
  ReceiveMessageReply_State_NON_EMPTY = 1,
  ReceiveMessageReply_State_ReceiveMessageReply_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReceiveMessageReply_State_ReceiveMessageReply_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReceiveMessageReply_State_IsValid(int value);
const ReceiveMessageReply_State ReceiveMessageReply_State_State_MIN = ReceiveMessageReply_State_EMPTY;
const ReceiveMessageReply_State ReceiveMessageReply_State_State_MAX = ReceiveMessageReply_State_NON_EMPTY;
const int ReceiveMessageReply_State_State_ARRAYSIZE = ReceiveMessageReply_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiveMessageReply_State_descriptor();
inline const ::std::string& ReceiveMessageReply_State_Name(ReceiveMessageReply_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiveMessageReply_State_descriptor(), value);
}
inline bool ReceiveMessageReply_State_Parse(
    const ::std::string& name, ReceiveMessageReply_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiveMessageReply_State>(
    ReceiveMessageReply_State_descriptor(), name, value);
}
// ===================================================================

class ChatMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ChatMessage) */ {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessage& default_instance();

  void Swap(ChatMessage* other);

  // implements Message ----------------------------------------------

  inline ChatMessage* New() const { return New(NULL); }

  ChatMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string messages = 2;
  void clear_messages();
  static const int kMessagesFieldNumber = 2;
  const ::std::string& messages() const;
  void set_messages(const ::std::string& value);
  void set_messages(const char* value);
  void set_messages(const char* value, size_t size);
  ::std::string* mutable_messages();
  ::std::string* release_messages();
  void set_allocated_messages(::std::string* messages);

  // @@protoc_insertion_point(class_scope:chatserver.ChatMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr messages_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogInRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogInRequest) */ {
 public:
  LogInRequest();
  virtual ~LogInRequest();

  LogInRequest(const LogInRequest& from);

  inline LogInRequest& operator=(const LogInRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInRequest& default_instance();

  void Swap(LogInRequest* other);

  // implements Message ----------------------------------------------

  inline LogInRequest* New() const { return New(NULL); }

  LogInRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInRequest& from);
  void MergeFrom(const LogInRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogInRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chatserver.LogInRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogInRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogInReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogInReply) */ {
 public:
  LogInReply();
  virtual ~LogInReply();

  LogInReply(const LogInReply& from);

  inline LogInReply& operator=(const LogInReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInReply& default_instance();

  void Swap(LogInReply* other);

  // implements Message ----------------------------------------------

  inline LogInReply* New() const { return New(NULL); }

  LogInReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInReply& from);
  void MergeFrom(const LogInReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogInReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LogInReply_State State;
  static const State INVALID =
    LogInReply_State_INVALID;
  static const State ALREADY =
    LogInReply_State_ALREADY;
  static const State SUCCESS =
    LogInReply_State_SUCCESS;
  static inline bool State_IsValid(int value) {
    return LogInReply_State_IsValid(value);
  }
  static const State State_MIN =
    LogInReply_State_State_MIN;
  static const State State_MAX =
    LogInReply_State_State_MAX;
  static const int State_ARRAYSIZE =
    LogInReply_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return LogInReply_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return LogInReply_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return LogInReply_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string confirmation = 1;
  void clear_confirmation();
  static const int kConfirmationFieldNumber = 1;
  const ::std::string& confirmation() const;
  void set_confirmation(const ::std::string& value);
  void set_confirmation(const char* value);
  void set_confirmation(const char* value, size_t size);
  ::std::string* mutable_confirmation();
  ::std::string* release_confirmation();
  void set_allocated_confirmation(::std::string* confirmation);

  // optional string user = 2;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional .chatserver.LogInReply.State logInState = 3;
  void clear_loginstate();
  static const int kLogInStateFieldNumber = 3;
  ::chatserver::LogInReply_State loginstate() const;
  void set_loginstate(::chatserver::LogInReply_State value);

  // @@protoc_insertion_point(class_scope:chatserver.LogInReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr confirmation_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  int loginstate_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogInReply* default_instance_;
};
// -------------------------------------------------------------------

class LogOutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogOutRequest) */ {
 public:
  LogOutRequest();
  virtual ~LogOutRequest();

  LogOutRequest(const LogOutRequest& from);

  inline LogOutRequest& operator=(const LogOutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOutRequest& default_instance();

  void Swap(LogOutRequest* other);

  // implements Message ----------------------------------------------

  inline LogOutRequest* New() const { return New(NULL); }

  LogOutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOutRequest& from);
  void MergeFrom(const LogOutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogOutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chatserver.LogOutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogOutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogOutReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogOutReply) */ {
 public:
  LogOutReply();
  virtual ~LogOutReply();

  LogOutReply(const LogOutReply& from);

  inline LogOutReply& operator=(const LogOutReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOutReply& default_instance();

  void Swap(LogOutReply* other);

  // implements Message ----------------------------------------------

  inline LogOutReply* New() const { return New(NULL); }

  LogOutReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOutReply& from);
  void MergeFrom(const LogOutReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogOutReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string confirmation = 1;
  void clear_confirmation();
  static const int kConfirmationFieldNumber = 1;
  const ::std::string& confirmation() const;
  void set_confirmation(const ::std::string& value);
  void set_confirmation(const char* value);
  void set_confirmation(const char* value, size_t size);
  ::std::string* mutable_confirmation();
  ::std::string* release_confirmation();
  void set_allocated_confirmation(::std::string* confirmation);

  // @@protoc_insertion_point(class_scope:chatserver.LogOutReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr confirmation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogOutReply* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.SendMessageRequest) */ {
 public:
  SendMessageRequest();
  virtual ~SendMessageRequest();

  SendMessageRequest(const SendMessageRequest& from);

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageRequest& default_instance();

  void Swap(SendMessageRequest* other);

  // implements Message ----------------------------------------------

  inline SendMessageRequest* New() const { return New(NULL); }

  SendMessageRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageRequest& from);
  void MergeFrom(const SendMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SendMessageRequest_State State;
  static const State INITIAL =
    SendMessageRequest_State_INITIAL;
  static const State PROCESSING =
    SendMessageRequest_State_PROCESSING;
  static inline bool State_IsValid(int value) {
    return SendMessageRequest_State_IsValid(value);
  }
  static const State State_MIN =
    SendMessageRequest_State_State_MIN;
  static const State State_MAX =
    SendMessageRequest_State_State_MAX;
  static const int State_ARRAYSIZE =
    SendMessageRequest_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return SendMessageRequest_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return SendMessageRequest_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return SendMessageRequest_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string recipient = 2;
  void clear_recipient();
  static const int kRecipientFieldNumber = 2;
  const ::std::string& recipient() const;
  void set_recipient(const ::std::string& value);
  void set_recipient(const char* value);
  void set_recipient(const char* value, size_t size);
  ::std::string* mutable_recipient();
  ::std::string* release_recipient();
  void set_allocated_recipient(::std::string* recipient);

  // optional string messages = 3;
  void clear_messages();
  static const int kMessagesFieldNumber = 3;
  const ::std::string& messages() const;
  void set_messages(const ::std::string& value);
  void set_messages(const char* value);
  void set_messages(const char* value, size_t size);
  ::std::string* mutable_messages();
  ::std::string* release_messages();
  void set_allocated_messages(::std::string* messages);

  // optional .chatserver.SendMessageRequest.State requestState = 4;
  void clear_requeststate();
  static const int kRequestStateFieldNumber = 4;
  ::chatserver::SendMessageRequest_State requeststate() const;
  void set_requeststate(::chatserver::SendMessageRequest_State value);

  // @@protoc_insertion_point(class_scope:chatserver.SendMessageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr recipient_;
  ::google::protobuf::internal::ArenaStringPtr messages_;
  int requeststate_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static SendMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.SendMessageReply) */ {
 public:
  SendMessageReply();
  virtual ~SendMessageReply();

  SendMessageReply(const SendMessageReply& from);

  inline SendMessageReply& operator=(const SendMessageReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageReply& default_instance();

  void Swap(SendMessageReply* other);

  // implements Message ----------------------------------------------

  inline SendMessageReply* New() const { return New(NULL); }

  SendMessageReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageReply& from);
  void MergeFrom(const SendMessageReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendMessageReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SendMessageReply_State State;
  static const State EXIST =
    SendMessageReply_State_EXIST;
  static const State NO_EXIST =
    SendMessageReply_State_NO_EXIST;
  static inline bool State_IsValid(int value) {
    return SendMessageReply_State_IsValid(value);
  }
  static const State State_MIN =
    SendMessageReply_State_State_MIN;
  static const State State_MAX =
    SendMessageReply_State_State_MAX;
  static const int State_ARRAYSIZE =
    SendMessageReply_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return SendMessageReply_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return SendMessageReply_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return SendMessageReply_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string confirmation = 1;
  void clear_confirmation();
  static const int kConfirmationFieldNumber = 1;
  const ::std::string& confirmation() const;
  void set_confirmation(const ::std::string& value);
  void set_confirmation(const char* value);
  void set_confirmation(const char* value, size_t size);
  ::std::string* mutable_confirmation();
  ::std::string* release_confirmation();
  void set_allocated_confirmation(::std::string* confirmation);

  // optional .chatserver.SendMessageReply.State recipientState = 2;
  void clear_recipientstate();
  static const int kRecipientStateFieldNumber = 2;
  ::chatserver::SendMessageReply_State recipientstate() const;
  void set_recipientstate(::chatserver::SendMessageReply_State value);

  // @@protoc_insertion_point(class_scope:chatserver.SendMessageReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr confirmation_;
  int recipientstate_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static SendMessageReply* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ReceiveMessageRequest) */ {
 public:
  ReceiveMessageRequest();
  virtual ~ReceiveMessageRequest();

  ReceiveMessageRequest(const ReceiveMessageRequest& from);

  inline ReceiveMessageRequest& operator=(const ReceiveMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveMessageRequest& default_instance();

  void Swap(ReceiveMessageRequest* other);

  // implements Message ----------------------------------------------

  inline ReceiveMessageRequest* New() const { return New(NULL); }

  ReceiveMessageRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveMessageRequest& from);
  void MergeFrom(const ReceiveMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chatserver.ReceiveMessageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ReceiveMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveMessageReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ReceiveMessageReply) */ {
 public:
  ReceiveMessageReply();
  virtual ~ReceiveMessageReply();

  ReceiveMessageReply(const ReceiveMessageReply& from);

  inline ReceiveMessageReply& operator=(const ReceiveMessageReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveMessageReply& default_instance();

  void Swap(ReceiveMessageReply* other);

  // implements Message ----------------------------------------------

  inline ReceiveMessageReply* New() const { return New(NULL); }

  ReceiveMessageReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveMessageReply& from);
  void MergeFrom(const ReceiveMessageReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveMessageReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReceiveMessageReply_State State;
  static const State EMPTY =
    ReceiveMessageReply_State_EMPTY;
  static const State NON_EMPTY =
    ReceiveMessageReply_State_NON_EMPTY;
  static inline bool State_IsValid(int value) {
    return ReceiveMessageReply_State_IsValid(value);
  }
  static const State State_MIN =
    ReceiveMessageReply_State_State_MIN;
  static const State State_MAX =
    ReceiveMessageReply_State_State_MAX;
  static const int State_ARRAYSIZE =
    ReceiveMessageReply_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return ReceiveMessageReply_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return ReceiveMessageReply_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return ReceiveMessageReply_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string messages = 1;
  void clear_messages();
  static const int kMessagesFieldNumber = 1;
  const ::std::string& messages() const;
  void set_messages(const ::std::string& value);
  void set_messages(const char* value);
  void set_messages(const char* value, size_t size);
  ::std::string* mutable_messages();
  ::std::string* release_messages();
  void set_allocated_messages(::std::string* messages);

  // optional string confirmation = 2;
  void clear_confirmation();
  static const int kConfirmationFieldNumber = 2;
  const ::std::string& confirmation() const;
  void set_confirmation(const ::std::string& value);
  void set_confirmation(const char* value);
  void set_confirmation(const char* value, size_t size);
  ::std::string* mutable_confirmation();
  ::std::string* release_confirmation();
  void set_allocated_confirmation(::std::string* confirmation);

  // optional .chatserver.ReceiveMessageReply.State queueState = 3;
  void clear_queuestate();
  static const int kQueueStateFieldNumber = 3;
  ::chatserver::ReceiveMessageReply_State queuestate() const;
  void set_queuestate(::chatserver::ReceiveMessageReply_State value);

  // @@protoc_insertion_point(class_scope:chatserver.ReceiveMessageReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr messages_;
  ::google::protobuf::internal::ArenaStringPtr confirmation_;
  int queuestate_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ReceiveMessageReply* default_instance_;
};
// -------------------------------------------------------------------

class ListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ListRequest) */ {
 public:
  ListRequest();
  virtual ~ListRequest();

  ListRequest(const ListRequest& from);

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRequest& default_instance();

  void Swap(ListRequest* other);

  // implements Message ----------------------------------------------

  inline ListRequest* New() const { return New(NULL); }

  ListRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRequest& from);
  void MergeFrom(const ListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string list = 1;
  void clear_list();
  static const int kListFieldNumber = 1;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // @@protoc_insertion_point(class_scope:chatserver.ListRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ListRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ListReply) */ {
 public:
  ListReply();
  virtual ~ListReply();

  ListReply(const ListReply& from);

  inline ListReply& operator=(const ListReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListReply& default_instance();

  void Swap(ListReply* other);

  // implements Message ----------------------------------------------

  inline ListReply* New() const { return New(NULL); }

  ListReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListReply& from);
  void MergeFrom(const ListReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string list = 1;
  void clear_list();
  static const int kListFieldNumber = 1;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // @@protoc_insertion_point(class_scope:chatserver.ListReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ListReply* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChatMessage

// optional string user = 1;
inline void ChatMessage::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatMessage::user() const {
  // @@protoc_insertion_point(field_get:chatserver.ChatMessage.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ChatMessage.user)
}
inline void ChatMessage::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ChatMessage.user)
}
inline void ChatMessage::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ChatMessage.user)
}
inline ::std::string* ChatMessage::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ChatMessage.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMessage::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.ChatMessage.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ChatMessage.user)
}

// optional string messages = 2;
inline void ChatMessage::clear_messages() {
  messages_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatMessage::messages() const {
  // @@protoc_insertion_point(field_get:chatserver.ChatMessage.messages)
  return messages_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_messages(const ::std::string& value) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ChatMessage.messages)
}
inline void ChatMessage::set_messages(const char* value) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ChatMessage.messages)
}
inline void ChatMessage::set_messages(const char* value, size_t size) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ChatMessage.messages)
}
inline ::std::string* ChatMessage::mutable_messages() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ChatMessage.messages)
  return messages_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMessage::release_messages() {
  // @@protoc_insertion_point(field_release:chatserver.ChatMessage.messages)
  
  return messages_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_allocated_messages(::std::string* messages) {
  if (messages != NULL) {
    
  } else {
    
  }
  messages_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messages);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ChatMessage.messages)
}

// -------------------------------------------------------------------

// LogInRequest

// optional string user = 1;
inline void LogInRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogInRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogInRequest.user)
}
inline void LogInRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogInRequest.user)
}
inline void LogInRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogInRequest.user)
}
inline ::std::string* LogInRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogInRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.LogInRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInRequest.user)
}

// -------------------------------------------------------------------

// LogInReply

// optional string confirmation = 1;
inline void LogInReply::clear_confirmation() {
  confirmation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogInReply::confirmation() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInReply.confirmation)
  return confirmation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInReply::set_confirmation(const ::std::string& value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogInReply.confirmation)
}
inline void LogInReply::set_confirmation(const char* value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogInReply.confirmation)
}
inline void LogInReply::set_confirmation(const char* value, size_t size) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogInReply.confirmation)
}
inline ::std::string* LogInReply::mutable_confirmation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogInReply.confirmation)
  return confirmation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInReply::release_confirmation() {
  // @@protoc_insertion_point(field_release:chatserver.LogInReply.confirmation)
  
  return confirmation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInReply::set_allocated_confirmation(::std::string* confirmation) {
  if (confirmation != NULL) {
    
  } else {
    
  }
  confirmation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), confirmation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInReply.confirmation)
}

// optional string user = 2;
inline void LogInReply::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogInReply::user() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInReply.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInReply::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogInReply.user)
}
inline void LogInReply::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogInReply.user)
}
inline void LogInReply::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogInReply.user)
}
inline ::std::string* LogInReply::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogInReply.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInReply::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.LogInReply.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInReply::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInReply.user)
}

// optional .chatserver.LogInReply.State logInState = 3;
inline void LogInReply::clear_loginstate() {
  loginstate_ = 0;
}
inline ::chatserver::LogInReply_State LogInReply::loginstate() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInReply.logInState)
  return static_cast< ::chatserver::LogInReply_State >(loginstate_);
}
inline void LogInReply::set_loginstate(::chatserver::LogInReply_State value) {
  
  loginstate_ = value;
  // @@protoc_insertion_point(field_set:chatserver.LogInReply.logInState)
}

// -------------------------------------------------------------------

// LogOutRequest

// optional string user = 1;
inline void LogOutRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOutRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.LogOutRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogOutRequest.user)
}
inline void LogOutRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogOutRequest.user)
}
inline void LogOutRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogOutRequest.user)
}
inline ::std::string* LogOutRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogOutRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOutRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.LogOutRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogOutRequest.user)
}

// -------------------------------------------------------------------

// LogOutReply

// optional string confirmation = 1;
inline void LogOutReply::clear_confirmation() {
  confirmation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOutReply::confirmation() const {
  // @@protoc_insertion_point(field_get:chatserver.LogOutReply.confirmation)
  return confirmation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutReply::set_confirmation(const ::std::string& value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogOutReply.confirmation)
}
inline void LogOutReply::set_confirmation(const char* value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogOutReply.confirmation)
}
inline void LogOutReply::set_confirmation(const char* value, size_t size) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogOutReply.confirmation)
}
inline ::std::string* LogOutReply::mutable_confirmation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogOutReply.confirmation)
  return confirmation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOutReply::release_confirmation() {
  // @@protoc_insertion_point(field_release:chatserver.LogOutReply.confirmation)
  
  return confirmation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutReply::set_allocated_confirmation(::std::string* confirmation) {
  if (confirmation != NULL) {
    
  } else {
    
  }
  confirmation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), confirmation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogOutReply.confirmation)
}

// -------------------------------------------------------------------

// SendMessageRequest

// optional string user = 1;
inline void SendMessageRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.user)
}
inline void SendMessageRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageRequest.user)
}
inline void SendMessageRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageRequest.user)
}
inline ::std::string* SendMessageRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageRequest.user)
}

// optional string recipient = 2;
inline void SendMessageRequest::clear_recipient() {
  recipient_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::recipient() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.recipient)
  return recipient_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_recipient(const ::std::string& value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.recipient)
}
inline void SendMessageRequest::set_recipient(const char* value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageRequest.recipient)
}
inline void SendMessageRequest::set_recipient(const char* value, size_t size) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageRequest.recipient)
}
inline ::std::string* SendMessageRequest::mutable_recipient() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageRequest.recipient)
  return recipient_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_recipient() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageRequest.recipient)
  
  return recipient_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_recipient(::std::string* recipient) {
  if (recipient != NULL) {
    
  } else {
    
  }
  recipient_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recipient);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageRequest.recipient)
}

// optional string messages = 3;
inline void SendMessageRequest::clear_messages() {
  messages_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::messages() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.messages)
  return messages_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_messages(const ::std::string& value) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.messages)
}
inline void SendMessageRequest::set_messages(const char* value) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageRequest.messages)
}
inline void SendMessageRequest::set_messages(const char* value, size_t size) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageRequest.messages)
}
inline ::std::string* SendMessageRequest::mutable_messages() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageRequest.messages)
  return messages_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_messages() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageRequest.messages)
  
  return messages_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_messages(::std::string* messages) {
  if (messages != NULL) {
    
  } else {
    
  }
  messages_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messages);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageRequest.messages)
}

// optional .chatserver.SendMessageRequest.State requestState = 4;
inline void SendMessageRequest::clear_requeststate() {
  requeststate_ = 0;
}
inline ::chatserver::SendMessageRequest_State SendMessageRequest::requeststate() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.requestState)
  return static_cast< ::chatserver::SendMessageRequest_State >(requeststate_);
}
inline void SendMessageRequest::set_requeststate(::chatserver::SendMessageRequest_State value) {
  
  requeststate_ = value;
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.requestState)
}

// -------------------------------------------------------------------

// SendMessageReply

// optional string confirmation = 1;
inline void SendMessageReply::clear_confirmation() {
  confirmation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageReply::confirmation() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageReply.confirmation)
  return confirmation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageReply::set_confirmation(const ::std::string& value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageReply.confirmation)
}
inline void SendMessageReply::set_confirmation(const char* value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageReply.confirmation)
}
inline void SendMessageReply::set_confirmation(const char* value, size_t size) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageReply.confirmation)
}
inline ::std::string* SendMessageReply::mutable_confirmation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageReply.confirmation)
  return confirmation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageReply::release_confirmation() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageReply.confirmation)
  
  return confirmation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageReply::set_allocated_confirmation(::std::string* confirmation) {
  if (confirmation != NULL) {
    
  } else {
    
  }
  confirmation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), confirmation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageReply.confirmation)
}

// optional .chatserver.SendMessageReply.State recipientState = 2;
inline void SendMessageReply::clear_recipientstate() {
  recipientstate_ = 0;
}
inline ::chatserver::SendMessageReply_State SendMessageReply::recipientstate() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageReply.recipientState)
  return static_cast< ::chatserver::SendMessageReply_State >(recipientstate_);
}
inline void SendMessageReply::set_recipientstate(::chatserver::SendMessageReply_State value) {
  
  recipientstate_ = value;
  // @@protoc_insertion_point(field_set:chatserver.SendMessageReply.recipientState)
}

// -------------------------------------------------------------------

// ReceiveMessageRequest

// optional string user = 1;
inline void ReceiveMessageRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReceiveMessageRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ReceiveMessageRequest.user)
}
inline void ReceiveMessageRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ReceiveMessageRequest.user)
}
inline void ReceiveMessageRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ReceiveMessageRequest.user)
}
inline ::std::string* ReceiveMessageRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceiveMessageRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageRequest.user)
}

// -------------------------------------------------------------------

// ReceiveMessageReply

// optional string messages = 1;
inline void ReceiveMessageReply::clear_messages() {
  messages_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReceiveMessageReply::messages() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageReply.messages)
  return messages_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageReply::set_messages(const ::std::string& value) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ReceiveMessageReply.messages)
}
inline void ReceiveMessageReply::set_messages(const char* value) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ReceiveMessageReply.messages)
}
inline void ReceiveMessageReply::set_messages(const char* value, size_t size) {
  
  messages_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ReceiveMessageReply.messages)
}
inline ::std::string* ReceiveMessageReply::mutable_messages() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageReply.messages)
  return messages_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceiveMessageReply::release_messages() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageReply.messages)
  
  return messages_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageReply::set_allocated_messages(::std::string* messages) {
  if (messages != NULL) {
    
  } else {
    
  }
  messages_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messages);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageReply.messages)
}

// optional string confirmation = 2;
inline void ReceiveMessageReply::clear_confirmation() {
  confirmation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReceiveMessageReply::confirmation() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageReply.confirmation)
  return confirmation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageReply::set_confirmation(const ::std::string& value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ReceiveMessageReply.confirmation)
}
inline void ReceiveMessageReply::set_confirmation(const char* value) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ReceiveMessageReply.confirmation)
}
inline void ReceiveMessageReply::set_confirmation(const char* value, size_t size) {
  
  confirmation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ReceiveMessageReply.confirmation)
}
inline ::std::string* ReceiveMessageReply::mutable_confirmation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageReply.confirmation)
  return confirmation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceiveMessageReply::release_confirmation() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageReply.confirmation)
  
  return confirmation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageReply::set_allocated_confirmation(::std::string* confirmation) {
  if (confirmation != NULL) {
    
  } else {
    
  }
  confirmation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), confirmation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageReply.confirmation)
}

// optional .chatserver.ReceiveMessageReply.State queueState = 3;
inline void ReceiveMessageReply::clear_queuestate() {
  queuestate_ = 0;
}
inline ::chatserver::ReceiveMessageReply_State ReceiveMessageReply::queuestate() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageReply.queueState)
  return static_cast< ::chatserver::ReceiveMessageReply_State >(queuestate_);
}
inline void ReceiveMessageReply::set_queuestate(::chatserver::ReceiveMessageReply_State value) {
  
  queuestate_ = value;
  // @@protoc_insertion_point(field_set:chatserver.ReceiveMessageReply.queueState)
}

// -------------------------------------------------------------------

// ListRequest

// optional string list = 1;
inline void ListRequest::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListRequest::list() const {
  // @@protoc_insertion_point(field_get:chatserver.ListRequest.list)
  return list_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListRequest::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ListRequest.list)
}
inline void ListRequest::set_list(const char* value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ListRequest.list)
}
inline void ListRequest::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ListRequest.list)
}
inline ::std::string* ListRequest::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ListRequest.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListRequest::release_list() {
  // @@protoc_insertion_point(field_release:chatserver.ListRequest.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListRequest::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ListRequest.list)
}

// -------------------------------------------------------------------

// ListReply

// optional string list = 1;
inline void ListReply::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListReply::list() const {
  // @@protoc_insertion_point(field_get:chatserver.ListReply.list)
  return list_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListReply::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ListReply.list)
}
inline void ListReply::set_list(const char* value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ListReply.list)
}
inline void ListReply::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ListReply.list)
}
inline ::std::string* ListReply::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ListReply.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListReply::release_list() {
  // @@protoc_insertion_point(field_release:chatserver.ListReply.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListReply::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ListReply.list)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chatserver

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::chatserver::LogInReply_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chatserver::LogInReply_State>() {
  return ::chatserver::LogInReply_State_descriptor();
}
template <> struct is_proto_enum< ::chatserver::SendMessageRequest_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chatserver::SendMessageRequest_State>() {
  return ::chatserver::SendMessageRequest_State_descriptor();
}
template <> struct is_proto_enum< ::chatserver::SendMessageReply_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chatserver::SendMessageReply_State>() {
  return ::chatserver::SendMessageReply_State_descriptor();
}
template <> struct is_proto_enum< ::chatserver::ReceiveMessageReply_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chatserver::ReceiveMessageReply_State>() {
  return ::chatserver::ReceiveMessageReply_State_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chatserver_2eproto__INCLUDED
